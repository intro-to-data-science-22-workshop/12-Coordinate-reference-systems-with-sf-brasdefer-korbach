<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Coordinate Reference Systems with sf</title>
    <meta charset="utf-8" />
    <meta name="author" content="Brasdefer/ Korbach" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="simons-touch.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Coordinate Reference Systems with sf
]
.subtitle[
## IDS WS 2022
]
.author[
### Brasdefer/ Korbach
]
.institute[
### Hertie School | <a href="https://github.com/intro-to-data-science-22-workshop">GRAD-C11/E1339</a>
]

---



&lt;style type="text/css"&gt;
@media print { # print out incremental slides; see https://stackoverflow.com/questions/56373198/get-xaringan-incremental-animations-to-print-to-pdf/56374619#56374619
  .has-continuation {
    display: block !important;
  }
}
&lt;/style&gt;








# Presentation Outline




&lt;br&gt;

.pull-left[
.pull-left[
##1: Background


1.1 [Why Measure the World?](#motivation)

1.2 [How to Measure the World?](#technical_info)

1.3 [CRS definition](#)


]

.pull-right[
##2: sf Package

2.1 [Simple Features Overview](#disambiguation)

2.2 [sf Geometry](#polygons)

2.3 [sf objects in R](#dataframes)

]

]

.pull-right[


##3: Functions, Operations

3.1 [Key Functions](#)

3.2 [Operations](#)

3.3 [Applications 1](#dataframes)
]




---
class: inverse, center, middle
name: section1

# 1: Background for the Package

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px style="width:1000px; margin:auto;"/&gt;&lt;/html&gt;





---
# 1.1 Why Measure the World?
&lt;br&gt;

.pull-left[

&lt;img src="pics/standardmap.png"&gt;

]

--
.pull-right[

&lt;br&gt;

**Motivation for Mapping, Projections...**

- Visualising data with maps

- Working with spatial data (there is so much information we don't see!)



]

---
class: inverse, center, middle
name: goal


#Goal: Ability to measure distance between any two points in the world






---
# 1.2 How to Measure the World?


&lt;img src="pics/earthtoplane.png" width="800px" height="400px" style = "position:absolute; right:200px; top:130px;"&gt;


---
# 1.3 Coordinate Reference Systems

###Coordinate Reference Systems (CRS)

- A CRS **specifies** which **location on earth** the spatial elements or coordinates of the data refer to
- CRSs are either **geographic** or **projected**

|   |  Geographic Coordinate System (GCS) | Projected Coordinate System (PCS) |
|---|---|---|
| Model | Ellipsoidal (datums: geocentric or local) | Cartesian plane (map projections from GCS into 2D) |
| Coordinates | Longitude (East-West) and Latitude (North-South) | Easting and Northing |
| Units | Degrees | Linear unit (e.g. metres) |
| Common example | WGS 84 | NAD83 |

###Projected Coordinate Systems
- Based on a geographic CRS and **projects a 3D surface** onto a flat surface
- Datum is transferred to a planar (cartesian) coordinate system using **conic**, **cylindrical** or **planar** projections
- This process **distorts some properties of the earthâ€™s surface** (e.g. area, direction, distance, and shape)

---
# 1.3 Coordinate Reference Systems

&lt;img src="pics/cylconplan.png" width="500px" height="300px" style = "position:absolute; right:50px; top:200px;" &gt;

&lt;img src="pics/GCSvsPCS.png" width="500px" height="300px" style = "position:absolute; right:650px; top:200px;" &gt;


---
# 1.3 Coordinate Reference Systems

.pull-left[

###CRS Components
A CRS comprises of
- An Earth ellipsoid
- A datum
- A map projection (expect for geographic coordinate systems)
- An origin point and
- A unit of measurement

###Common standards for CRS
- EPSG
- proj4
- Well-known Text (WKT)
]

.pull-right[

```r
R&gt; st_crs(world)
```

```
## Coordinate Reference System:
##   User input: EPSG:4326 
##   wkt:
## GEOGCRS["WGS 84",
##     DATUM["World Geodetic System 1984",
##         ELLIPSOID["WGS 84",6378137,298.257223563,
##             LENGTHUNIT["metre",1]]],
##     PRIMEM["Greenwich",0,
##         ANGLEUNIT["degree",0.0174532925199433]],
##     CS[ellipsoidal,2],
##         AXIS["geodetic latitude (Lat)",north,
##             ORDER[1],
##             ANGLEUNIT["degree",0.0174532925199433]],
##         AXIS["geodetic longitude (Lon)",east,
##             ORDER[2],
##             ANGLEUNIT["degree",0.0174532925199433]],
##     USAGE[
##         SCOPE["Horizontal component of 3D system."],
##         AREA["World."],
##         BBOX[-90,-180,90,180]],
##     ID["EPSG",4326]]
```
]





---
class: inverse, center, middle
name: section1

# 2: The 'Simple Features' Package

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px style="width:1000px; margin:auto;"/&gt;&lt;/html&gt;





---
# 2.1 'Simple Features' Overview
&lt;br&gt;

.pull-left[

&lt;img src="pics/sflogo.png" width="400px" height="400px" style = "position:absolute; left:90px; top:190px;" &gt;

]

--

.pull-right[
**Simple Features** is a formal standard that **describes how 'features' can be represented in computers and stored in databases**


**Features** are 'objects in the real world'
- House, Street, City, Country, ...

**Geometries** of features describe where on Earth the feature is located and are composed of coordinates in a 2-, 3- or 4-dimensional space 
- XY, XYZ, ...

**Attributes** of a feature contain more specific information about the feature itself
- Population, Height, Colour, Temperature

]



---
# 2.2 sf Geometry Visualization



&lt;img src="pics/geometrytypes.png" width="800px" height="500px" style = "position:absolute; left:200px; top:100px;"  &gt;



---
# 2.3 The Simple Features Object in R

###Simple Features data frames
1. All features are **stored in a DataFrame** with columns for the attributes (sf object)
3. Each feature **'Geometry'** is saved **as a list** element (sfg object)
3. The **'Geometries'** are put in a list-column called `geometry` or `geom` (sfc object)



&lt;img src="pics/sftibble.png" width="800px" height="350px" style = "position:absolute; left:50px; bottom:20px;"  &gt;







---
# Grammar of XPath

### Navigational operators `"."`and `".."`

- `"."` accesses elements on the same level ("self axis"), which is useful when working with predicates (see later!).
- `".."` accesses elements at a higher hierarchical level.


```r
R&gt; #html_elements(parsed_doc, xpath = "//title/..")
```


```r
R&gt; #html_elements(parsed_doc, xpath = "//div[starts-with(./@id, 'R')]")
```













---
# Content extraction 

- Until now, we used XPath expressions to extract complete nodes or nodesets (that is, elements with tags).
- However, in most cases we're interested in extracting the content only.
- To that end, we can use extractor functions that are applied on the output of XPath query calls.

| Function  |  Argument | Return value |
|---|---|---|
| `html_text()` |  | Element value |
| `html_text2()` |  | Element value (with a bit more cleanup) |
| `html_attr()` | `name` | Element attribute |
| `html_attrs()` |  | (All) element attributes |
| `html_name()` | `trim` | Element name |
| `html_children()` |  | Element children |

























---
# More XPath?

### Training resources

- XPath is a little language of its own. As always with languages, mastery comes with practice.
- A good environment for practice is the [XPath expression testbed at whitebeam.org](http://www.whitebeam.org/library/guide/TechNotes/xpathtestbed.rhtm).
- Also check out this [cheat sheet](https://devhints.io/xpath).

### XPath creator tools

- Now, do you really have to construct XPath expressions by your own? No! At least not always.
- **SelectorGadget**: [http://selectorgadget.com](http://selectorgadget.com) is a browser plugin that constructs XPath statements via a point-and-click approach. The generated expressions are not always efficient and effective though (more on this later).
- Web developer tools - the internal browser functionality to study the DOM, among other things, also lets you extract XPath statements for selected nodes. These are specific to unique nodes/elements though, and therefore less helpful to extract node sets. (But they come in handy when we want to script live navigation, e.g. for Selenium.)

















---
# What is CSS?

.pull-left[
### Background

- **C**ascading **S**tyle **S**heets (CSS) is a style sheet language that allows web developers to adjust the "look and feel" of websites.
- By using CSS to adjust style features such as layout, colors, and fonts, it's easier to separate content (HTML) from presentation (CSS).

### Three ways to insert CSS into HTML

1. **External CSS.** Inside `&lt;head&gt;` with a reference to the external file inside the `&lt;link&gt;` element.
2. **Internal CSS.** Inside `&lt;head&gt;` and stored in `&lt;style&gt;` elements. 
3. **Inline CSS.** Inside `&lt;body&gt;` using the `style` attribute of elements.
  
]

--

.pull-right[
**External CSS**

```html
&lt;head&gt;
  &lt;link rel="stylesheet" href="mystyle.css"&gt;
&lt;/head&gt;
```

**Internal CSS**

```html
&lt;head&gt;
   &lt;style&gt;
      h1 {
         color: red;
         margin-left: 20px;
      }
   &lt;/style&gt;
&lt;/head&gt;
```

**Inline CSS**

```html
&lt;p style="color: blue;"&gt;This is a paragraph.&lt;/p&gt;
```
]


















---
class: inverse, center, middle
name: regex

# Regular expressions

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px style="width:1000px; margin:auto;"/&gt;&lt;/html&gt;
















---
# What are regular expressions?

.pull-left[
### Definition

Regular expressions a.k.a. *regex* or *RegExp* is a tool - a little language of it's own really - that lets you describe patterns in text/strings.

Funnily, a regular expression itself is a sequence of characters, some with special, some with literal meaning.

Regular expressions are widely applicable and implemented in many programming languages, including R, as well as search engines, search and replace dialogs, etc.

&lt;div align="center"&gt;
&lt;img src="pics/character-string.png" height=100&gt;
&lt;/div&gt;
]

--

.pull-right[
### Why is this useful for web scraping?

Information on the web can often be described by patterns (think email addresses, numbers, cells in HTML tables, ...).

If the data of interest follow specific patterns, we can match and extract them - regardless of page layout and HTML overhead.

Whenever the information of interest is (stored in) text, regular expressions are useful for extraction and tidying purposes.
]





















---
# Backreferencing *cont.* 

**Goal:** Match a word that does not include  "a" until the word appears the second time.

**Solution:**


```r
R&gt; #str_extract(example.obj, "([ [:punct:]][b-z]+[ [:punct:]]).+?\\1")
```

**How it works:**

- Match all letters without a, therefore: `[b-z]`
- Match complete words with beginning/end: `[ [:punct:]]`
- Define first word pattern* `(...)`
- Match anything between occurrences of both words: `.+?`
- Refer to original word `\\1`















    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"hash": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
